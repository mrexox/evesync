#!/usr/bin/env ruby
# -*- mode: ruby -*-

require 'optparse'
require 'socket'
require 'find'
require 'zip'
require 'fileutils'
require 'evesync'
require 'evesync/log'
require 'evesync/utils'
require 'evesync/database'
require 'evesync/config'
require 'evesync/sync'
require 'evesync/ipc/client'

DB_TAG = 'db'
FILES_TAG = 'files'

opts = {}
$program = File.basename($0)
#Evesync::Log.level = :warn
Evesync::Log.simple = true

OptionParser.new do |parser|
  parser.banner = "#{$program} [OPTIONS...]

"
  parser.summary_width = 20

  parser.on('-l', '--load FILE', 'Load events from file') do |f|
    unless File.file? f
      puts "File is absent: #{f}"
      exit 1
    end
    opts['load_file'] = f
  end

  parser.on('-z', '--zip [DEST]', 'Zip current database') do |d|

    # Pretty default name
    hostname = Socket.gethostname
    hostname = hostname == 'localhost' \
               ? Evesync::Utils::local_ip : hostname
    time_now = Time.now.strftime('%Y.%m.%d-%H:%M:%S')
    opts['zip'] = d || "#{$program}_#{hostname}_#{time_now}.zip"

    # Validation
    unless File.directory? File.dirname opts['zip']
      puts "Directory doesn't exist: #{File.dirname opts['zip']}"
      exit 1
    end
  end

  parser.on('-f', '--force', 'Enforce synchronization') do
    opts['sync'] = true
  end

  parser.on_tail('-v', '--version', "Version of #{$program}") do
    puts Evesync::VERSION
    exit
  end

  parser.on_tail('-h', '--help', 'Help message') do
    puts parser
    exit
  end

  # TODO: refactor
  parser.on('-r', '--run', 'Start daemons') do
    r, w = IO.pipe
    data_pid = spawn('evedatad', :err => '/var/log/evesync/evedatad.log', :out=>:err)
    mon_pid = spawn('evemond', :err => '/var/log/evesync/evemond.log', :out=>:err)
    hand_pid = spawn('evehand', :err => '/var/log/evesync/evehand.log', :out=>:err)
    sync_pid = spawn('evesyncd', :err => '/var/log/evesync/evesyncd.log', :out=>:err)
    FileUtils.mkdir_p('/var/run/evesync')
    File.write('/var/run/evesync/evedatad.pid', data_pid)
    File.write('/var/run/evesync/evemond.pid', mon_pid)
    File.write('/var/run/evesync/evehand.pid', hand_pid)
    File.write('/var/run/evesync/evesyncd.pid', sync_pid)
  end

  parser.on('-k', '--kill', 'Stop daemons') do
    begin
    Process.kill('TERM', File.read('/var/run/evesync/evemond.pid').to_i)
    Process.kill('TERM', File.read('/var/run/evesync/evehand.pid').to_i)
    Process.kill('TERM', File.read('/var/run/evesync/evesyncd.pid').to_i)
    Process.kill('TERM', File.read('/var/run/evesync/evedatad.pid').to_i)
    rescue Errno::ESRCH => e
      puts('Some process already killed')
    rescue StandardError => e
      puts("Error: #{e}")
      puts('Something went wrong while killing processes. Do it yourself!')
    ensure
      FileUtils.rm_f Dir.glob('/var/run/evesync/*.pid')
    end
  end
end.parse!

def force_sync
  sync_client = Evesync::IPC::Client.new(
    port: :evesyncd
  )
  sync_client.synchronize
end

def files_in(folder)
  begin
    Find.find(folder).collect { |file| file }
  rescue StandardError
    puts "No files in #{folder}"
    []
  end
end

def zip(out)
  databases = {
    DB_TAG => {
      Evesync::Config[:evedatad]['db_path'] =>
      files_in(Evesync::Config[:evedatad]['db_path'])
    },
    FILES_TAG => {
      Evesync::Config[:evedatad]['db_files_path'] =>
      files_in(Evesync::Config[:evedatad]['db_files_path'])
    }
  }

  Zip::File.open(out, Zip::File::CREATE) do |zip|
    databases.each do |key, entries|
      entries.each do |base_path, files|
        files.each do |file|
          relative_path = Pathname.new(file)
                            .relative_path_from(Pathname.new(base_path))
          zip.add(File.join(key, relative_path.to_s), file)
        end
      end
    end
  end
end

def load_file(filename)

  Dir.mktmpdir($program) do |tmpdir|
    # Unpacking...
    Zip::File.open(filename) do |zip|
      zip.each do |entry|
        entry.extract(File.join(tmpdir, entry.name))
      end
    end

    db_path = File.join(tmpdir, DB_TAG)
    db_files_path = File.join(tmpdir, FILES_TAG)

    loaded_db = Evesync::Database.new(
      db_path,
      db_files_path
    )

    local_db = Evesync::IPC::Client.new(
      port: :evedatad
    )

    diff = Evesync::Sync::diff_missed(
      v1: local_db.events,
      v2: loaded_db.events
    )

    new_messages = loaded_db.messages(diff)

    sync_client = Evesync::IPC::Client.new(
      port: :evesyncd
    )

    sync_client.apply_events(new_messages)
  end

end

def evesync(opts)
  if opts['sync']
    puts 'Synchronization enforced'
    force_sync
  end

  if opts['load_file']
    load_file opts['load_file']
  end

  if opts['zip']
    zip(opts['zip'])
    puts(opts['zip'])
  end
end

evesync opts
